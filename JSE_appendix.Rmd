---
title: "Appendix"
author:
  - name: "Florence Puech"
  - name: "Eric Marcon"
abstract: >
  Code to reproduce the map of the main text.
date: "`r format(Sys.time(), '%d %B %Y')`"
url: https://ericmarcon.github.io/JSE_appendix/
github-repo: ericmarcon/JSE_appendix
# Language
lang: en-US
# Bibliography
bibliography: references.bib
biblio-style: chicago
# LaTeX
# Print table of contents in PDFs?
pdftoc: false
# If true, choose its depth
toc-depth: 3
# URL color
urlcolor: blue
# Do not modify
always_allow_html: yes
csquotes: true
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    css: style.css
    code_folding: show
  bookdown::pdf_book:
    template: latex/template.tex
    citation_package: natbib
    latex_engine: xelatex
    keep_tex: yes
  rmdformats::downcute:
    use_bookdown: yes
    lightbox: yes
  bookdown::word_document2: default
  bookdown::gitbook:
    config:
      download: "pdf"
      sharing:
        github: yes
---

```{r DoNotModify, include=FALSE}
### Utilities. Do not modify.
# Installation of packages if necessary
InstallPackages <- function(Packages) {
  InstallPackage <- function(Package) {
    if (!Package %in% installed.packages()[, 1]) {
      install.packages(Package, repos="https://cran.rstudio.com/")
    }
  }
  invisible(sapply(Packages, InstallPackage))
}

# Basic packages
InstallPackages(c("bookdown", "formatR", "kableExtra", "ragg"))

# kableExtra must be loaded 
if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "docx") {
  # Word output (https://stackoverflow.com/questions/35144130/in-knitr-how-can-i-test-for-if-the-output-will-be-pdf-or-word)
  # Do not use autoformat (https://github.com/haozhu233/kableExtra/issues/308)
  options(kableExtra.auto_format = FALSE)
}
library("kableExtra")

# Chunk font size hook: allows size='small' or any valid Latex font size in chunk options
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})
```

```{r Options, include=FALSE}
### Customized options for this document
# Add necessary packages here
Packages <- c("tidyverse")
# Install them
InstallPackages(Packages)

# knitr options
knitr::opts_chunk$set(
  cache =   FALSE,    # Cache chunk results
  include = TRUE,     # Show/Hide chunks
  echo =    TRUE,     # Show/Hide code
  warning = FALSE,    # Show/Hide warnings
  message = FALSE,    # Show/Hide messages
  # Figure alignment and size
  fig.align = 'center', out.width = '80%',
  # Graphic devices (ragg_png is better than standard png)
  dev = c("ragg_png", "pdf"),
  # Code chunk format
  tidy = TRUE, tidy.opts = list(blank=FALSE, width.cutoff=50),
  size = "scriptsize", knitr.graphics.auto_pdf = TRUE
  )
options(width = 50)

# ggplot style
library("tidyverse", "sf")
theme_set(theme_bw())
theme_update(panel.background=element_rect(fill="transparent", colour=NA),
             plot.background=element_rect(fill="transparent", colour=NA))
knitr::opts_chunk$set(dev.args=list(bg="transparent"))

# Random seed
set.seed(973)
```

# Data

## Data wrangling

Data are stored in `trees_2021.zip` which contains two GeoJSON files:

- trees_2021 stores all trees of the city of Paris in 2021.
- trees_logged contains all trees logged 

They must be read.
Data are projected into the Lambert 93 datum.
Coordinates are then in meters.

```{r data}
unzip("data/trees_2021.zip", exdir = "data")
library("sf")
read_sf("data/trees_2021.geojson") %>% 
  st_transform(crs = 2154) -> 
  trees_all
read_sf("data/trees_logged.geojson") %>% 
  st_transform(crs = 2154) -> 
  trees_logged
```


### All trees

```{r}
trees_all %>% 
  # Bind the coordinates
  bind_cols(as.data.frame(st_coordinates(trees_all)))
            %>% 
```


```{r}
# Tree description
trees_all_Lambert93@data %>%
  # Make a tibble for easier handling
  as_tibble() %>% 
  # Bind the coordinates
  bind_cols(as.data.frame(trees_all_Lambert93@coords)) %>% 
  # Filter Suzanne Lenglen park
  filter(adresse == "PARC OMNISPORT SUZANNE LENGLEN / 7 BOULEVARD DES FRERES VOISIN") %>% 
  # Delete useless fields
  select(-idemplacement, -typeemplacement, 
         -adresse, -complementadresse,   
         -geo_point_2d1, -geo_point_2d2,
         -stadedeveloppement, -remarquable) %>%
  # Create a numeric tree ID
  mutate(ID = as.integer(idbase)) %>% 
  # Create a field with the species name
  mutate(Species_name = as.factor(paste(genre, espece))) %>%
  # Create a field with the status
  mutate(Status = "Alive") %>%
  # Genus and Species fields
  mutate(Genus = as.factor(genre)) %>% 
  mutate(Species = as.factor(espece)) %>% 
  # Rename and finally select columns
  rename(French_species_name = libellefrancais,
         X = coords.x1,
         Y = coords.x2,
         Circumference = circonferenceencm) %>% 
  select(ID, Species_name, Status, Genus, Species, French_species_name, X, Y, Circumference) -> 
  trees_all

# Number of trees
trees_all %>% nrow()
```

### Logged trees

```{r}
# Tree description
trees_logged_Lambert93@data %>%
  # Make a tibble for easier handling
  as_tibble() %>% 
  # Bind the coordinates
  bind_cols(as.data.frame(trees_logged_Lambert93@coords)) %>% 
  # Filter Suzanne Lenglen park
  filter(adresse == "PARC OMNISPORT SUZANNE LENGLEN / 7 BOULEVARD DES FRERES VOISIN") %>% 
  # Exclude unidentified trees
  filter(!is.na(especearbreprecedent), !is.na(libellefrancaisarbreprecedent), !is.na(genrearbreprecedent)) %>%
  filter(libellefrancaisarbreprecedent != "Non spécifié") %>%
  filter(especearbreprecedent != "n. sp.") %>% 
  # Delete useless fields
  select(-adresse, -especefutur, -datedernierabattage, -varieteoucultivarfutur,
         -genrefutur, -geo_point_2d1, -geo_point_2d2) %>%
  # Create a numeric tree ID
  mutate(ID = as.integer(idbase)) %>% 
  # Create a field with the species name
  mutate(Species_name = as.factor(paste(genrearbreprecedent, especearbreprecedent))) %>%
  # Create a field with the status
  mutate(Status = "Logged") %>%
  # Genus and Species fields
  mutate(Genus = as.factor(genrearbreprecedent)) %>% 
  mutate(Species = as.factor(especearbreprecedent)) %>% 
  # Reason for logging (in French)
  mutate(Logging_reason = motifabattagearbreprecedent) %>% 
  # Rename and finally select columns
  rename(French_species_name = libellefrancaisarbreprecedent,
         X = coords.x1,
         Y = coords.x2) %>% 
  select(ID, Species_name, Status, Genus, Species, Logging_reason, French_species_name, X, Y) -> 
  trees_logged

# Number of trees
trees_logged %>% nrow()
```

### Merge

```{r}
# All trees
trees_all %>%
  # Delete the Circumference column that is not in trees_logged
  mutate(Circumference = NULL) %>% 
  # Delete logged trees
  anti_join(trees_logged, by = "ID") %>%
  # Bind the logged trees
  bind_rows(trees_logged) -> trees
```

Circumferences of all trees, including logged ones, are in `tree_all` from where they can be extracted.

```{r}
trees_all %>%
  select(ID, Circumference) %>%
  inner_join(trees, by = "ID") ->
  trees
```

### Short logging reasons

```{r}
trees$Logging_reason %>% 
  str_replace("Arbre.*", "Decaying") %>% 
  str_replace("Foyer.*", "Infected") ->
  trees$Logging_reason
```


### Factors

```{r}
trees$Logging_reason <- as.factor(trees$Logging_reason)
trees$Status <- as.factor(trees$Status)
trees$French_species_name <- as.factor(trees$French_species_name)
```

## Point patterns

```{r}
library("dbmss")
trees %>%
  # Weight is the basal area
  mutate(PointWeight = Circumference^2 / 4 / pi) %>%
  mutate(
    PointType = ifelse(
      Logging_reason == "Infected", 
      "Infected", 
      as.character(Genus)
    )
  ) %>%
  as.wmppp(unitname = c("meter", "meters")) ->
  trees_infected
autoplot(trees_infected)
```





# Concentration

## M_i

```{r}
trees_infected %>% 
   Mhat(
     ReferenceType = "Infected",
     NeighborType = "Acer", 
     Individual = TRUE
  ) ->
  M_trees_infected
```





`r if (!knitr:::is_latex_output()) '# References {-}'`
